// DO NOT EDIT. This file is generated

#include "../Precompiled.h"
#include "../AngelScript/APITemplates.h"

#include "../AngelScript/GeneratedIncludes.h"
#include "../AngelScript/Manual.h"

namespace Urho3D
{

void FakeAddRef(void* ptr);
void FakeReleaseRef(void* ptr);

void ASRegisterGenerated_Members_Cn_Cz(asIScriptEngine* engine)
{
#ifdef URHO3D_URHO2D
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CollisionBox2D::RegisterObject(Context* context) | File: ../Urho2D/CollisionBox2D.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_CollisionShape2D
    REGISTER_MANUAL_PART_CollisionShape2D(CollisionBox2D, "CollisionBox2D")
#endif
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CollisionBox2D, "CollisionBox2D")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CollisionBox2D, "CollisionBox2D")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CollisionBox2D, "CollisionBox2D")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CollisionBox2D, "CollisionBox2D")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CollisionBox2D, "CollisionBox2D")
#endif
#ifdef REGISTER_MANUAL_PART_CollisionBox2D
    REGISTER_MANUAL_PART_CollisionBox2D(CollisionBox2D, "CollisionBox2D")
#endif
    RegisterSubclass<CollisionShape2D, CollisionBox2D>(engine, "CollisionShape2D", "CollisionBox2D");
    RegisterSubclass<Component, CollisionBox2D>(engine, "Component", "CollisionBox2D");
    RegisterSubclass<Animatable, CollisionBox2D>(engine, "Animatable", "CollisionBox2D");
    RegisterSubclass<Serializable, CollisionBox2D>(engine, "Serializable", "CollisionBox2D");
    RegisterSubclass<Object, CollisionBox2D>(engine, "Object", "CollisionBox2D");
    RegisterSubclass<RefCounted, CollisionBox2D>(engine, "RefCounted", "CollisionBox2D");
#endif

#ifdef URHO3D_URHO2D
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CollisionChain2D::RegisterObject(Context* context) | File: ../Urho2D/CollisionChain2D.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_CollisionShape2D
    REGISTER_MANUAL_PART_CollisionShape2D(CollisionChain2D, "CollisionChain2D")
#endif
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CollisionChain2D, "CollisionChain2D")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CollisionChain2D, "CollisionChain2D")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CollisionChain2D, "CollisionChain2D")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CollisionChain2D, "CollisionChain2D")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CollisionChain2D, "CollisionChain2D")
#endif
#ifdef REGISTER_MANUAL_PART_CollisionChain2D
    REGISTER_MANUAL_PART_CollisionChain2D(CollisionChain2D, "CollisionChain2D")
#endif
    RegisterSubclass<CollisionShape2D, CollisionChain2D>(engine, "CollisionShape2D", "CollisionChain2D");
    RegisterSubclass<Component, CollisionChain2D>(engine, "Component", "CollisionChain2D");
    RegisterSubclass<Animatable, CollisionChain2D>(engine, "Animatable", "CollisionChain2D");
    RegisterSubclass<Serializable, CollisionChain2D>(engine, "Serializable", "CollisionChain2D");
    RegisterSubclass<Object, CollisionChain2D>(engine, "Object", "CollisionChain2D");
    RegisterSubclass<RefCounted, CollisionChain2D>(engine, "RefCounted", "CollisionChain2D");
#endif

#ifdef URHO3D_URHO2D
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CollisionCircle2D::RegisterObject(Context* context) | File: ../Urho2D/CollisionCircle2D.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_CollisionShape2D
    REGISTER_MANUAL_PART_CollisionShape2D(CollisionCircle2D, "CollisionCircle2D")
#endif
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CollisionCircle2D, "CollisionCircle2D")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CollisionCircle2D, "CollisionCircle2D")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CollisionCircle2D, "CollisionCircle2D")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CollisionCircle2D, "CollisionCircle2D")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CollisionCircle2D, "CollisionCircle2D")
#endif
#ifdef REGISTER_MANUAL_PART_CollisionCircle2D
    REGISTER_MANUAL_PART_CollisionCircle2D(CollisionCircle2D, "CollisionCircle2D")
#endif
    RegisterSubclass<CollisionShape2D, CollisionCircle2D>(engine, "CollisionShape2D", "CollisionCircle2D");
    RegisterSubclass<Component, CollisionCircle2D>(engine, "Component", "CollisionCircle2D");
    RegisterSubclass<Animatable, CollisionCircle2D>(engine, "Animatable", "CollisionCircle2D");
    RegisterSubclass<Serializable, CollisionCircle2D>(engine, "Serializable", "CollisionCircle2D");
    RegisterSubclass<Object, CollisionCircle2D>(engine, "Object", "CollisionCircle2D");
    RegisterSubclass<RefCounted, CollisionCircle2D>(engine, "RefCounted", "CollisionCircle2D");
#endif

#ifdef URHO3D_URHO2D
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CollisionEdge2D::RegisterObject(Context* context) | File: ../Urho2D/CollisionEdge2D.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_CollisionShape2D
    REGISTER_MANUAL_PART_CollisionShape2D(CollisionEdge2D, "CollisionEdge2D")
#endif
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CollisionEdge2D, "CollisionEdge2D")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CollisionEdge2D, "CollisionEdge2D")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CollisionEdge2D, "CollisionEdge2D")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CollisionEdge2D, "CollisionEdge2D")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CollisionEdge2D, "CollisionEdge2D")
#endif
#ifdef REGISTER_MANUAL_PART_CollisionEdge2D
    REGISTER_MANUAL_PART_CollisionEdge2D(CollisionEdge2D, "CollisionEdge2D")
#endif
    RegisterSubclass<CollisionShape2D, CollisionEdge2D>(engine, "CollisionShape2D", "CollisionEdge2D");
    RegisterSubclass<Component, CollisionEdge2D>(engine, "Component", "CollisionEdge2D");
    RegisterSubclass<Animatable, CollisionEdge2D>(engine, "Animatable", "CollisionEdge2D");
    RegisterSubclass<Serializable, CollisionEdge2D>(engine, "Serializable", "CollisionEdge2D");
    RegisterSubclass<Object, CollisionEdge2D>(engine, "Object", "CollisionEdge2D");
    RegisterSubclass<RefCounted, CollisionEdge2D>(engine, "RefCounted", "CollisionEdge2D");
#endif

#ifdef URHO3D_URHO2D
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CollisionPolygon2D::RegisterObject(Context* context) | File: ../Urho2D/CollisionPolygon2D.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_CollisionShape2D
    REGISTER_MANUAL_PART_CollisionShape2D(CollisionPolygon2D, "CollisionPolygon2D")
#endif
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CollisionPolygon2D, "CollisionPolygon2D")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CollisionPolygon2D, "CollisionPolygon2D")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CollisionPolygon2D, "CollisionPolygon2D")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CollisionPolygon2D, "CollisionPolygon2D")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CollisionPolygon2D, "CollisionPolygon2D")
#endif
#ifdef REGISTER_MANUAL_PART_CollisionPolygon2D
    REGISTER_MANUAL_PART_CollisionPolygon2D(CollisionPolygon2D, "CollisionPolygon2D")
#endif
    RegisterSubclass<CollisionShape2D, CollisionPolygon2D>(engine, "CollisionShape2D", "CollisionPolygon2D");
    RegisterSubclass<Component, CollisionPolygon2D>(engine, "Component", "CollisionPolygon2D");
    RegisterSubclass<Animatable, CollisionPolygon2D>(engine, "Animatable", "CollisionPolygon2D");
    RegisterSubclass<Serializable, CollisionPolygon2D>(engine, "Serializable", "CollisionPolygon2D");
    RegisterSubclass<Object, CollisionPolygon2D>(engine, "Object", "CollisionPolygon2D");
    RegisterSubclass<RefCounted, CollisionPolygon2D>(engine, "RefCounted", "CollisionPolygon2D");
#endif

#ifdef URHO3D_PHYSICS
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CollisionShape::RegisterObject(Context* context) | File: ../Physics/CollisionShape.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CollisionShape, "CollisionShape")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CollisionShape, "CollisionShape")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CollisionShape, "CollisionShape")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CollisionShape, "CollisionShape")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CollisionShape, "CollisionShape")
#endif
#ifdef REGISTER_MANUAL_PART_CollisionShape
    REGISTER_MANUAL_PART_CollisionShape(CollisionShape, "CollisionShape")
#endif
    RegisterSubclass<Component, CollisionShape>(engine, "Component", "CollisionShape");
    RegisterSubclass<Animatable, CollisionShape>(engine, "Animatable", "CollisionShape");
    RegisterSubclass<Serializable, CollisionShape>(engine, "Serializable", "CollisionShape");
    RegisterSubclass<Object, CollisionShape>(engine, "Object", "CollisionShape");
    RegisterSubclass<RefCounted, CollisionShape>(engine, "RefCounted", "CollisionShape");
#endif

#ifdef URHO3D_URHO2D
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CollisionShape2D::RegisterObject(Context* context) | File: ../Urho2D/CollisionShape2D.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CollisionShape2D, "CollisionShape2D")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CollisionShape2D, "CollisionShape2D")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CollisionShape2D, "CollisionShape2D")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CollisionShape2D, "CollisionShape2D")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CollisionShape2D, "CollisionShape2D")
#endif
#ifdef REGISTER_MANUAL_PART_CollisionShape2D
    REGISTER_MANUAL_PART_CollisionShape2D(CollisionShape2D, "CollisionShape2D")
#endif
    RegisterSubclass<Component, CollisionShape2D>(engine, "Component", "CollisionShape2D");
    RegisterSubclass<Animatable, CollisionShape2D>(engine, "Animatable", "CollisionShape2D");
    RegisterSubclass<Serializable, CollisionShape2D>(engine, "Serializable", "CollisionShape2D");
    RegisterSubclass<Object, CollisionShape2D>(engine, "Object", "CollisionShape2D");
    RegisterSubclass<RefCounted, CollisionShape2D>(engine, "RefCounted", "CollisionShape2D");
#endif

    // float Color::a_ | File: ../Math/Color.h
    engine->RegisterObjectProperty("Color", "float a", offsetof(Color, a_));
    // const ChannelMask Color::ABGR | File: ../Math/Color.h
    // Error: type "const ChannelMask" can not automatically bind
    // const ChannelMask Color::ARGB | File: ../Math/Color.h
    // Error: type "const ChannelMask" can not automatically bind
    // float Color::b_ | File: ../Math/Color.h
    engine->RegisterObjectProperty("Color", "float b", offsetof(Color, b_));
    // const Color Color::BLACK | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color BLACK", (void*)&Color::BLACK);
    engine->SetDefaultNamespace("");
    // const Color Color::BLUE | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color BLUE", (void*)&Color::BLUE);
    engine->SetDefaultNamespace("");
    // const Color Color::CYAN | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color CYAN", (void*)&Color::CYAN);
    engine->SetDefaultNamespace("");
    // float Color::g_ | File: ../Math/Color.h
    engine->RegisterObjectProperty("Color", "float g", offsetof(Color, g_));
    // const Color Color::GRAY | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color GRAY", (void*)&Color::GRAY);
    engine->SetDefaultNamespace("");
    // const Color Color::GREEN | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color GREEN", (void*)&Color::GREEN);
    engine->SetDefaultNamespace("");
    // const Color Color::MAGENTA | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color MAGENTA", (void*)&Color::MAGENTA);
    engine->SetDefaultNamespace("");
    // float Color::r_ | File: ../Math/Color.h
    engine->RegisterObjectProperty("Color", "float r", offsetof(Color, r_));
    // const Color Color::RED | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color RED", (void*)&Color::RED);
    engine->SetDefaultNamespace("");
    // const Color Color::TRANSPARENT_BLACK | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color TRANSPARENT_BLACK", (void*)&Color::TRANSPARENT_BLACK);
    engine->SetDefaultNamespace("");
    // const Color Color::WHITE | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color WHITE", (void*)&Color::WHITE);
    engine->SetDefaultNamespace("");
    // const Color Color::YELLOW | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalProperty("const Color YELLOW", (void*)&Color::YELLOW);
    engine->SetDefaultNamespace("");
    // static float Color::ConvertGammaToLinear(float value) | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalFunction("float ConvertGammaToLinear(float)", AS_FUNCTIONPR(Color::ConvertGammaToLinear, (float), float), AS_CALL_CDECL);
    engine->SetDefaultNamespace("");
    // static float Color::ConvertLinearToGamma(float value) | File: ../Math/Color.h
    engine->SetDefaultNamespace("Color");
    engine->RegisterGlobalFunction("float ConvertLinearToGamma(float)", AS_FUNCTIONPR(Color::ConvertLinearToGamma, (float), float), AS_CALL_CDECL);
    engine->SetDefaultNamespace("");
#ifdef REGISTER_MANUAL_PART_Color
    REGISTER_MANUAL_PART_Color(Color, "Color")
#endif

    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void Animatable::RegisterObject(Context* context) | File: ../Scene/Animatable.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(Component, "Component")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(Component, "Component")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(Component, "Component")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(Component, "Component")
#endif
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(Component, "Component")
#endif
    RegisterSubclass<Animatable, Component>(engine, "Animatable", "Component");
    RegisterSubclass<Serializable, Component>(engine, "Serializable", "Component");
    RegisterSubclass<Object, Component>(engine, "Object", "Component");
    RegisterSubclass<RefCounted, Component>(engine, "RefCounted", "Component");

    // Condition& Condition::operator=(const Condition&) | Possible implicitly-declared
    RegisterImplicitlyDeclaredAssignOperatorIfPossible<Condition>(engine, "Condition");
#ifdef REGISTER_MANUAL_PART_Condition
    REGISTER_MANUAL_PART_Condition(Condition, "Condition")
#endif

#ifdef URHO3D_NETWORK
    // Controls Connection::controls_ | File: ../Network/Connection.h
    engine->RegisterObjectProperty("Connection", "Controls controls", offsetof(Connection, controls_));
    // VariantMap Connection::identity_ | File: ../Network/Connection.h
    engine->RegisterObjectProperty("Connection", "VariantMap identity", offsetof(Connection, identity_));
    // unsigned char Connection::timeStamp_ | File: ../Network/Connection.h
    engine->RegisterObjectProperty("Connection", "uint8 timeStamp", offsetof(Connection, timeStamp_));
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(Connection, "Connection")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(Connection, "Connection")
#endif
#ifdef REGISTER_MANUAL_PART_Connection
    REGISTER_MANUAL_PART_Connection(Connection, "Connection")
#endif
    RegisterSubclass<Object, Connection>(engine, "Object", "Connection");
    RegisterSubclass<RefCounted, Connection>(engine, "RefCounted", "Connection");
#endif

    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(Console, "Console")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(Console, "Console")
#endif
#ifdef REGISTER_MANUAL_PART_Console
    REGISTER_MANUAL_PART_Console(Console, "Console")
#endif
    RegisterSubclass<Object, Console>(engine, "Object", "Console");
    RegisterSubclass<RefCounted, Console>(engine, "RefCounted", "Console");

    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(ConstantBuffer, "ConstantBuffer")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(ConstantBuffer, "ConstantBuffer")
#endif
#ifdef REGISTER_MANUAL_PART_GPUObject
    REGISTER_MANUAL_PART_GPUObject(ConstantBuffer, "ConstantBuffer")
#endif
#ifdef REGISTER_MANUAL_PART_ConstantBuffer
    REGISTER_MANUAL_PART_ConstantBuffer(ConstantBuffer, "ConstantBuffer")
#endif
    RegisterSubclass<Object, ConstantBuffer>(engine, "Object", "ConstantBuffer");
    RegisterSubclass<RefCounted, ConstantBuffer>(engine, "RefCounted", "ConstantBuffer");

#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(Context, "Context")
#endif
#ifdef REGISTER_MANUAL_PART_Context
    REGISTER_MANUAL_PART_Context(Context, "Context")
#endif
    RegisterSubclass<RefCounted, Context>(engine, "RefCounted", "Context");

    // unsigned Controls::buttons_ | File: ../Input/Controls.h
    engine->RegisterObjectProperty("Controls", "uint buttons", offsetof(Controls, buttons_));
    // VariantMap Controls::extraData_ | File: ../Input/Controls.h
    engine->RegisterObjectProperty("Controls", "VariantMap extraData", offsetof(Controls, extraData_));
    // float Controls::pitch_ | File: ../Input/Controls.h
    engine->RegisterObjectProperty("Controls", "float pitch", offsetof(Controls, pitch_));
    // float Controls::yaw_ | File: ../Input/Controls.h
    engine->RegisterObjectProperty("Controls", "float yaw", offsetof(Controls, yaw_));
    // Controls& Controls::operator=(const Controls&) | Possible implicitly-declared
    RegisterImplicitlyDeclaredAssignOperatorIfPossible<Controls>(engine, "Controls");
#ifdef REGISTER_MANUAL_PART_Controls
    REGISTER_MANUAL_PART_Controls(Controls, "Controls")
#endif

#ifdef URHO3D_NAVIGATION
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CrowdAgent::RegisterObject(Context* context) | File: ../Navigation/CrowdAgent.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CrowdAgent, "CrowdAgent")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CrowdAgent, "CrowdAgent")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CrowdAgent, "CrowdAgent")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CrowdAgent, "CrowdAgent")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CrowdAgent, "CrowdAgent")
#endif
#ifdef REGISTER_MANUAL_PART_CrowdAgent
    REGISTER_MANUAL_PART_CrowdAgent(CrowdAgent, "CrowdAgent")
#endif
    RegisterSubclass<Component, CrowdAgent>(engine, "Component", "CrowdAgent");
    RegisterSubclass<Animatable, CrowdAgent>(engine, "Animatable", "CrowdAgent");
    RegisterSubclass<Serializable, CrowdAgent>(engine, "Serializable", "CrowdAgent");
    RegisterSubclass<Object, CrowdAgent>(engine, "Object", "CrowdAgent");
    RegisterSubclass<RefCounted, CrowdAgent>(engine, "RefCounted", "CrowdAgent");
#endif

#ifdef URHO3D_NAVIGATION
    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CrowdManager::RegisterObject(Context* context) | File: ../Navigation/CrowdManager.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CrowdManager, "CrowdManager")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CrowdManager, "CrowdManager")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CrowdManager, "CrowdManager")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CrowdManager, "CrowdManager")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CrowdManager, "CrowdManager")
#endif
#ifdef REGISTER_MANUAL_PART_CrowdManager
    REGISTER_MANUAL_PART_CrowdManager(CrowdManager, "CrowdManager")
#endif
    RegisterSubclass<Component, CrowdManager>(engine, "Component", "CrowdManager");
    RegisterSubclass<Animatable, CrowdManager>(engine, "Animatable", "CrowdManager");
    RegisterSubclass<Serializable, CrowdManager>(engine, "Serializable", "CrowdManager");
    RegisterSubclass<Object, CrowdManager>(engine, "Object", "CrowdManager");
    RegisterSubclass<RefCounted, CrowdManager>(engine, "RefCounted", "CrowdManager");
#endif

    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void Cursor::RegisterObject(Context* context) | File: ../UI/Cursor.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_BorderImage
    REGISTER_MANUAL_PART_BorderImage(Cursor, "Cursor")
#endif
#ifdef REGISTER_MANUAL_PART_UIElement
    REGISTER_MANUAL_PART_UIElement(Cursor, "Cursor")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(Cursor, "Cursor")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(Cursor, "Cursor")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(Cursor, "Cursor")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(Cursor, "Cursor")
#endif
#ifdef REGISTER_MANUAL_PART_Cursor
    REGISTER_MANUAL_PART_Cursor(Cursor, "Cursor")
#endif
    RegisterSubclass<BorderImage, Cursor>(engine, "BorderImage", "Cursor");
    RegisterSubclass<UIElement, Cursor>(engine, "UIElement", "Cursor");
    RegisterSubclass<Animatable, Cursor>(engine, "Animatable", "Cursor");
    RegisterSubclass<Serializable, Cursor>(engine, "Serializable", "Cursor");
    RegisterSubclass<Object, Cursor>(engine, "Object", "Cursor");
    RegisterSubclass<RefCounted, Cursor>(engine, "RefCounted", "Cursor");

    // static const TypeInfo* Object::GetTypeInfoStatic() | File: ../Core/Object.h
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // static void CustomGeometry::RegisterObject(Context* context) | File: ../Graphics/CustomGeometry.h
    // Not registered because have @nobind mark
#ifdef REGISTER_MANUAL_PART_Drawable
    REGISTER_MANUAL_PART_Drawable(CustomGeometry, "CustomGeometry")
#endif
#ifdef REGISTER_MANUAL_PART_Component
    REGISTER_MANUAL_PART_Component(CustomGeometry, "CustomGeometry")
#endif
#ifdef REGISTER_MANUAL_PART_Animatable
    REGISTER_MANUAL_PART_Animatable(CustomGeometry, "CustomGeometry")
#endif
#ifdef REGISTER_MANUAL_PART_Serializable
    REGISTER_MANUAL_PART_Serializable(CustomGeometry, "CustomGeometry")
#endif
#ifdef REGISTER_MANUAL_PART_Object
    REGISTER_MANUAL_PART_Object(CustomGeometry, "CustomGeometry")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CustomGeometry, "CustomGeometry")
#endif
#ifdef REGISTER_MANUAL_PART_CustomGeometry
    REGISTER_MANUAL_PART_CustomGeometry(CustomGeometry, "CustomGeometry")
#endif
    RegisterSubclass<Drawable, CustomGeometry>(engine, "Drawable", "CustomGeometry");
    RegisterSubclass<Component, CustomGeometry>(engine, "Component", "CustomGeometry");
    RegisterSubclass<Animatable, CustomGeometry>(engine, "Animatable", "CustomGeometry");
    RegisterSubclass<Serializable, CustomGeometry>(engine, "Serializable", "CustomGeometry");
    RegisterSubclass<Object, CustomGeometry>(engine, "Object", "CustomGeometry");
    RegisterSubclass<RefCounted, CustomGeometry>(engine, "RefCounted", "CustomGeometry");

#ifdef URHO3D_PHYSICS
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(CollisionGeometryData, "CollisionGeometryData")
#endif
#ifdef REGISTER_MANUAL_PART_CollisionGeometryData
    REGISTER_MANUAL_PART_CollisionGeometryData(CollisionGeometryData, "CollisionGeometryData")
#endif
    RegisterSubclass<RefCounted, CollisionGeometryData>(engine, "RefCounted", "CollisionGeometryData");
#endif

    // Color ColorFrame::color_ | File: ../Graphics/ParticleEffect.h
    engine->RegisterObjectProperty("ColorFrame", "Color color", offsetof(ColorFrame, color_));
    // float ColorFrame::time_ | File: ../Graphics/ParticleEffect.h
    engine->RegisterObjectProperty("ColorFrame", "float time", offsetof(ColorFrame, time_));
    // ColorFrame& ColorFrame::operator=(const ColorFrame&) | Possible implicitly-declared
    RegisterImplicitlyDeclaredAssignOperatorIfPossible<ColorFrame>(engine, "ColorFrame");
    engine->RegisterObjectBehaviour("ColorFrame", asBEHAVE_ADDREF, "void f()", AS_FUNCTION_OBJLAST(FakeAddRef), AS_CALL_CDECL_OBJLAST);
    engine->RegisterObjectBehaviour("ColorFrame", asBEHAVE_RELEASE, "void f()", AS_FUNCTION_OBJLAST(FakeReleaseRef), AS_CALL_CDECL_OBJLAST);
#ifdef REGISTER_MANUAL_PART_ColorFrame
    REGISTER_MANUAL_PART_ColorFrame(ColorFrame, "ColorFrame")
#endif

    // WeakPtr<Component> ComponentReplicationState::component_ | File: ../Scene/ReplicationState.h
    // Error: type "WeakPtr<Component>" can not automatically bind
    // Connection* ReplicationState::connection_ | File: ../Scene/ReplicationState.h
    // Connection* can not be registered
    // DirtyBits ComponentReplicationState::dirtyAttributes_ | File: ../Scene/ReplicationState.h
    engine->RegisterObjectProperty("ComponentReplicationState", "DirtyBits dirtyAttributes", offsetof(ComponentReplicationState, dirtyAttributes_));
    // NodeReplicationState* ComponentReplicationState::nodeState_ | File: ../Scene/ReplicationState.h
    // NodeReplicationState* can not be registered
    // ComponentReplicationState& ComponentReplicationState::operator=(const ComponentReplicationState&) | Possible implicitly-declared
    RegisterImplicitlyDeclaredAssignOperatorIfPossible<ComponentReplicationState>(engine, "ComponentReplicationState");
#ifdef REGISTER_MANUAL_PART_ReplicationState
    REGISTER_MANUAL_PART_ReplicationState(ComponentReplicationState, "ComponentReplicationState")
#endif
#ifdef REGISTER_MANUAL_PART_ComponentReplicationState
    REGISTER_MANUAL_PART_ComponentReplicationState(ComponentReplicationState, "ComponentReplicationState")
#endif

    // unsigned CompressedLevel::blockSize_ | File: ../Resource/Image.h
    engine->RegisterObjectProperty("CompressedLevel", "uint blockSize", offsetof(CompressedLevel, blockSize_));
    // unsigned char* CompressedLevel::data_ | File: ../Resource/Image.h
    // unsigned char* can not be registered
    // unsigned CompressedLevel::dataSize_ | File: ../Resource/Image.h
    engine->RegisterObjectProperty("CompressedLevel", "uint dataSize", offsetof(CompressedLevel, dataSize_));
    // int CompressedLevel::depth_ | File: ../Resource/Image.h
    engine->RegisterObjectProperty("CompressedLevel", "int depth", offsetof(CompressedLevel, depth_));
    // CompressedFormat CompressedLevel::format_ | File: ../Resource/Image.h
    engine->RegisterObjectProperty("CompressedLevel", "CompressedFormat format", offsetof(CompressedLevel, format_));
    // int CompressedLevel::height_ | File: ../Resource/Image.h
    engine->RegisterObjectProperty("CompressedLevel", "int height", offsetof(CompressedLevel, height_));
    // unsigned CompressedLevel::rows_ | File: ../Resource/Image.h
    engine->RegisterObjectProperty("CompressedLevel", "uint rows", offsetof(CompressedLevel, rows_));
    // unsigned CompressedLevel::rowSize_ | File: ../Resource/Image.h
    engine->RegisterObjectProperty("CompressedLevel", "uint rowSize", offsetof(CompressedLevel, rowSize_));
    // int CompressedLevel::width_ | File: ../Resource/Image.h
    engine->RegisterObjectProperty("CompressedLevel", "int width", offsetof(CompressedLevel, width_));
    // CompressedLevel& CompressedLevel::operator=(const CompressedLevel&) | Possible implicitly-declared
    RegisterImplicitlyDeclaredAssignOperatorIfPossible<CompressedLevel>(engine, "CompressedLevel");
#ifdef REGISTER_MANUAL_PART_CompressedLevel
    REGISTER_MANUAL_PART_CompressedLevel(CompressedLevel, "CompressedLevel")
#endif

#ifdef URHO3D_PHYSICS
    // unsigned ConvexData::indexCount_ | File: ../Physics/CollisionShape.h
    engine->RegisterObjectProperty("ConvexData", "uint indexCount", offsetof(ConvexData, indexCount_));
    // SharedArrayPtr<unsigned> ConvexData::indexData_ | File: ../Physics/CollisionShape.h
    // Error: type "SharedArrayPtr<unsigned>" can not automatically bind
    // unsigned ConvexData::vertexCount_ | File: ../Physics/CollisionShape.h
    engine->RegisterObjectProperty("ConvexData", "uint vertexCount", offsetof(ConvexData, vertexCount_));
    // SharedArrayPtr<Vector3> ConvexData::vertexData_ | File: ../Physics/CollisionShape.h
    // Error: type "SharedArrayPtr<Vector3>" can not automatically bind
#ifdef REGISTER_MANUAL_PART_CollisionGeometryData
    REGISTER_MANUAL_PART_CollisionGeometryData(ConvexData, "ConvexData")
#endif
#ifdef REGISTER_MANUAL_PART_RefCounted
    REGISTER_MANUAL_PART_RefCounted(ConvexData, "ConvexData")
#endif
#ifdef REGISTER_MANUAL_PART_ConvexData
    REGISTER_MANUAL_PART_ConvexData(ConvexData, "ConvexData")
#endif
    RegisterSubclass<CollisionGeometryData, ConvexData>(engine, "CollisionGeometryData", "ConvexData");
    RegisterSubclass<RefCounted, ConvexData>(engine, "RefCounted", "ConvexData");
#endif

#ifdef URHO3D_NAVIGATION
    // unsigned char CrowdObstacleAvoidanceParams::adaptiveDepth | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "uint8 adaptiveDepth", offsetof(CrowdObstacleAvoidanceParams, adaptiveDepth));
    // unsigned char CrowdObstacleAvoidanceParams::adaptiveDivs | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "uint8 adaptiveDivs", offsetof(CrowdObstacleAvoidanceParams, adaptiveDivs));
    // unsigned char CrowdObstacleAvoidanceParams::adaptiveRings | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "uint8 adaptiveRings", offsetof(CrowdObstacleAvoidanceParams, adaptiveRings));
    // unsigned char CrowdObstacleAvoidanceParams::gridSize | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "uint8 gridSize", offsetof(CrowdObstacleAvoidanceParams, gridSize));
    // float CrowdObstacleAvoidanceParams::horizTime | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "float horizTime", offsetof(CrowdObstacleAvoidanceParams, horizTime));
    // float CrowdObstacleAvoidanceParams::velBias | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "float velBias", offsetof(CrowdObstacleAvoidanceParams, velBias));
    // float CrowdObstacleAvoidanceParams::weightCurVel | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "float weightCurVel", offsetof(CrowdObstacleAvoidanceParams, weightCurVel));
    // float CrowdObstacleAvoidanceParams::weightDesVel | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "float weightDesVel", offsetof(CrowdObstacleAvoidanceParams, weightDesVel));
    // float CrowdObstacleAvoidanceParams::weightSide | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "float weightSide", offsetof(CrowdObstacleAvoidanceParams, weightSide));
    // float CrowdObstacleAvoidanceParams::weightToi | File: ../Navigation/CrowdManager.h
    engine->RegisterObjectProperty("CrowdObstacleAvoidanceParams", "float weightToi", offsetof(CrowdObstacleAvoidanceParams, weightToi));
    // CrowdObstacleAvoidanceParams& CrowdObstacleAvoidanceParams::operator=(const CrowdObstacleAvoidanceParams&) | Possible implicitly-declared
    RegisterImplicitlyDeclaredAssignOperatorIfPossible<CrowdObstacleAvoidanceParams>(engine, "CrowdObstacleAvoidanceParams");
#ifdef REGISTER_MANUAL_PART_CrowdObstacleAvoidanceParams
    REGISTER_MANUAL_PART_CrowdObstacleAvoidanceParams(CrowdObstacleAvoidanceParams, "CrowdObstacleAvoidanceParams")
#endif
#endif

    // IntVector2 CursorShapeInfo::hotSpot_ | File: ../UI/Cursor.h
    engine->RegisterObjectProperty("CursorShapeInfo", "IntVector2 hotSpot", offsetof(CursorShapeInfo, hotSpot_));
    // SharedPtr<Image> CursorShapeInfo::image_ | File: ../UI/Cursor.h
    // Error: type "SharedPtr<Image>" can not automatically bind
    // IntRect CursorShapeInfo::imageRect_ | File: ../UI/Cursor.h
    engine->RegisterObjectProperty("CursorShapeInfo", "IntRect imageRect", offsetof(CursorShapeInfo, imageRect_));
    // SDL_Cursor* CursorShapeInfo::osCursor_ | File: ../UI/Cursor.h
    // SDL_Cursor* can not be registered
    // int CursorShapeInfo::systemCursor_ | File: ../UI/Cursor.h
    engine->RegisterObjectProperty("CursorShapeInfo", "int systemCursor", offsetof(CursorShapeInfo, systemCursor_));
    // bool CursorShapeInfo::systemDefined_ | File: ../UI/Cursor.h
    engine->RegisterObjectProperty("CursorShapeInfo", "bool systemDefined", offsetof(CursorShapeInfo, systemDefined_));
    // SharedPtr<Texture> CursorShapeInfo::texture_ | File: ../UI/Cursor.h
    // Error: type "SharedPtr<Texture>" can not automatically bind
    // CursorShapeInfo& CursorShapeInfo::operator=(const CursorShapeInfo&) | Possible implicitly-declared
    RegisterImplicitlyDeclaredAssignOperatorIfPossible<CursorShapeInfo>(engine, "CursorShapeInfo");
#ifdef REGISTER_MANUAL_PART_CursorShapeInfo
    REGISTER_MANUAL_PART_CursorShapeInfo(CursorShapeInfo, "CursorShapeInfo")
#endif

    // unsigned CustomGeometryVertex::color_ | File: ../Graphics/CustomGeometry.h
    engine->RegisterObjectProperty("CustomGeometryVertex", "uint color", offsetof(CustomGeometryVertex, color_));
    // Vector3 CustomGeometryVertex::normal_ | File: ../Graphics/CustomGeometry.h
    engine->RegisterObjectProperty("CustomGeometryVertex", "Vector3 normal", offsetof(CustomGeometryVertex, normal_));
    // Vector3 CustomGeometryVertex::position_ | File: ../Graphics/CustomGeometry.h
    engine->RegisterObjectProperty("CustomGeometryVertex", "Vector3 position", offsetof(CustomGeometryVertex, position_));
    // Vector4 CustomGeometryVertex::tangent_ | File: ../Graphics/CustomGeometry.h
    engine->RegisterObjectProperty("CustomGeometryVertex", "Vector4 tangent", offsetof(CustomGeometryVertex, tangent_));
    // Vector2 CustomGeometryVertex::texCoord_ | File: ../Graphics/CustomGeometry.h
    engine->RegisterObjectProperty("CustomGeometryVertex", "Vector2 texCoord", offsetof(CustomGeometryVertex, texCoord_));
    // CustomGeometryVertex& CustomGeometryVertex::operator=(const CustomGeometryVertex&) | Possible implicitly-declared
    RegisterImplicitlyDeclaredAssignOperatorIfPossible<CustomGeometryVertex>(engine, "CustomGeometryVertex");
    engine->RegisterObjectBehaviour("CustomGeometryVertex", asBEHAVE_ADDREF, "void f()", AS_FUNCTION_OBJLAST(FakeAddRef), AS_CALL_CDECL_OBJLAST);
    engine->RegisterObjectBehaviour("CustomGeometryVertex", asBEHAVE_RELEASE, "void f()", AS_FUNCTION_OBJLAST(FakeReleaseRef), AS_CALL_CDECL_OBJLAST);
#ifdef REGISTER_MANUAL_PART_CustomGeometryVertex
    REGISTER_MANUAL_PART_CustomGeometryVertex(CustomGeometryVertex, "CustomGeometryVertex")
#endif

}

}
